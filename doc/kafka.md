***kafka***

kafka消费者通过向broker的leader分区发起“提取”请求。
消费者指定每次请求日志的偏移量并收到那一块日志的起始位置。
因此，消费者可以重新指定位置，重新消费。

1、推送 vs 拉取:

    我们考虑的第一个问题是消费者应该从broker中pull数据还是broker向消费者push数据，在这方面，kafka遵循比较传统的设计，
    大多数消息系统，生产者推消息到broker，消费者从broker拉取消息，一些日志中心的系统，比如 Scribe 和Apache Flume ，
    采用非常不同的push模式（push数据到下游）。事实上，push模式和pull模式各有优劣。push模式很难适应消费速率不同的消费者，
    因为消息发送速率是由broker决定的。push模式的目标是尽可能以最快速度传递消息，但是这样很容易造成消费者来不及处理消息，
    典型的表现就是拒绝服务以及网络拥塞。而pull模式则可以根据consumer的消费能力以适当的速率消费消息。

消息传递保障:

    kafka提供了生产者和消费者之间的担保语义。有多种可能的消息传递保证可以提供：
    1、最多一次 --- 消息可能丢失，但绝不会重发。
    2、至少一次 --- 消息绝不会丢失，但有可能重新发送。
    3、正好一次 --- 这是人们真正想要的，每个消息传递一次且仅一次。


副本：

	kafka集群在各个服务器上备份topic分区中日志（ps：就是备份我们的消息，称为副本，你可以设置每个topic的副本数）。
	当集群中某个服务器发生故障时，自动切换到这些副本，从而保障在故障时消息仍然可用。

    副本以topic的分区为单位。在正常情况下，kafka每个分区都有一个单独的leader，
    0个或多个follower。副本的总数包括leader。所有的读取和写入到该分区的leader。
    通常，分区数比broker多，leader均匀分布在broker。follower的日志完全等同于leader的日志 — 
    相同的顺序相同的偏移量和消息（当然，在任何一个时间点上，leader比follower多几条消息，
    尚未同步到follower）
	
***Kuberentes***

 
Docker是虚拟机的一种，比传统的vm虚拟机更轻量，更小。 但是，docker没有脑子，和vm一样，它只会启动和销毁应用（武断），这就是单机版的docker，所以，集群的docker，需要一个leader来指挥它们，告诉它们，你部署10个A应用，另外一台docker你部署20个A应用，你部署的ip分别是172.168.xx.xx。leader来收集docker反馈的性能信息，当leader在部署新应用的时候，会优先考虑那些空闲的docker。当发现某个docker性能到极限的时候，就指挥它们进行迁移分布。而leader就是Kubernetes。来充当指挥官的角色。